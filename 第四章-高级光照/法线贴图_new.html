<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <title>法线贴图</title>
    <script src="../lib/webgl-utils.js"></script>
    <script src="../lib/webgl-debug.js"></script>
    <script src="../lib/cuon-utils.js"></script>
    <script src="../lib/cuon-matrix.js"></script>
    <script type="text/javascript">
        // LightedCube.js (c) 2012 matsuda
        // Vertex shader program
        //法线贴图的shader
        var VSHADER_SOURCE =
        `
        //incoming Position attribute from our SpriteBatch
        attribute vec4 a_Position;
        attribute vec4 Color;
        attribute vec2 TexCoord0;
        
        uniform mat4 u_MvpMatrix;
        uniform mat4 u_normalMatrix;   //transpose(inverse(u_ModelMatrix))这个过程在js里算的
        uniform mat4 u_ModelMatrix;    // Model matrix

        varying vec2 vTexCoord0;
        varying vec4 vColor;

        void main(void ) {
           gl_Position = u_MvpMatrix * a_Position;
           vTexCoord0 = TexCoord0;
           vColor = Color;
        }
        `;
        var FSHADER_SOURCE =
          `#ifdef GL_ES
           precision mediump float;
           #endif

           //fixed number of lights
           //#define N_LIGHTS 2

           //attributes from vertex shader
           varying vec4 vColor;
           varying vec2 vTexCoord0;

            //our texture samplers
           uniform sampler2D u_texture0;   //diffuse map
           uniform sampler2D u_normals;   //normal map

           //values used for shading algorithm...
           uniform vec2 Resolution;      //resolution of canvas
           uniform vec4 AmbientColor;    //ambient RGBA -- alpha is intensity

           /*
           uniform vec3 LightPos[N_LIGHTS];     //light position, normalized
           uniform vec4 LightColor[N_LIGHTS];   //light RGBA -- alpha is intensity
           uniform vec3 Falloff[N_LIGHTS];      //attenuation coefficients
           */

           uniform vec3 LightPos;     //light position, normalized
           uniform vec4 LightColor;   //light RGBA -- alpha is intensity
           uniform vec3 Falloff;      //attenuation coefficients
           // uniform float Test[2];

           void main() {
	            //RGBA of our diffuse color
	            vec4 DiffuseColor = texture2D(u_texture0, vTexCoord0);

	             //RGB of our normal map
	             vec3 NormalMap = texture2D(u_normals, vTexCoord0).rgb;

	             vec3 Sum = vec3(0.0);

	             //for (int i=0; i<N_LIGHTS; i++) {
		              //The delta position of light
		              vec3 LightDir = vec3(LightPos.xy - (gl_FragCoord.xy / Resolution.xy), LightPos.z);

		               //Correct for aspect ratio
		              LightDir.x *= Resolution.x / Resolution.y;

		              //Determine distance (used for attenuation) BEFORE we normalize our LightDir
		              float D = length(LightDir);

		              //normalize our vectors
		              vec3 N = normalize(NormalMap * 2.0 - 1.0);
		              vec3 L = normalize(LightDir);

		              //Some normal maps may need to be inverted like so:
		              // N.y = 1.0 - N.y;

		              //Pre-multiply light color with intensity
		              //Then perform "N dot L" to determine our diffuse term
		              vec3 Diffuse = (LightColor.rgb * LightColor.a) * max(dot(N, L), 0.0);

		              //pre-multiply ambient color with intensity
		              vec3 Ambient = AmbientColor.rgb * AmbientColor.a;

		              //calculate attenuation
		              float Attenuation = 1.0 / ( Falloff.x + (Falloff.y*D) + (Falloff.z*D*D) );

		              //the calculation which brings it all together
		              vec3 Intensity = Ambient + Diffuse * Attenuation;
		              vec3 FinalColor = DiffuseColor.rgb * Intensity;

		              Sum += FinalColor;
	              //}

	              gl_FragColor = vColor * vec4(Sum, DiffuseColor.a);
                }
             `;
              // Fragment shader program

        var VSHADER_SOURCE_LIGHT =
            `attribute vec4 a_Position;
            uniform mat4 u_lightmvpMatrix;
            void main() {
               gl_Position = u_lightmvpMatrix * a_Position;
          }`;

        var FSHADER_SOURCE_LIGHT =
          `#ifdef GL_ES
          precision mediump float;
          uniform vec3 u_lightColor;
          #endif
          void main() {
          vec4 color = vec4(u_lightColor, 1.0);
            gl_FragColor = vec4(1.0);
        }`;

        var cameraPos, light_Pos;
        var canvas;
        var mouse = { x: 0, y: 0 }, scroll = 0, time = 0;
        var lastTime = 0, now = Date.now();
        var MAPWITH = 512, MAPHEIGHT = 512;
        function main() {
            // Retrieve <canvas> element
            canvas = document.getElementById('webgl');
            // Get the rendering context for WebGL
            var gl = getWebGLContext(canvas);
            if (!gl) {
                console.log('Failed to get the rendering context for WebGL');
                return;
            }

            // Initialize shaders
            var lightProgram = createProgram(gl, VSHADER_SOURCE_LIGHT, FSHADER_SOURCE_LIGHT);
            var planeProgram = createProgram(gl, VSHADER_SOURCE, FSHADER_SOURCE);
            if (!lightProgram || !planeProgram) {
                console.log('Failed to intialize shaders.');
                return;
            }

            // Get storage locations of attribute and uniform variables in program object for single color drawing
            lightProgram.a_Position = gl.getAttribLocation(lightProgram, 'a_Position');
            lightProgram.u_lightColor = gl.getUniformLocation(lightProgram, 'u_lightColor');
            lightProgram.u_lightmvpMatrix = gl.getUniformLocation(lightProgram, 'u_lightmvpMatrix');

            // Get storage locations of attribute and uniform variables in program object for texture drawing
            planeProgram.Color = gl.getAttribLocation(planeProgram, 'Color');//
            planeProgram.u_lightColor = gl.getUniformLocation(planeProgram, 'LightColor');//
            planeProgram.u_lightPos = gl.getUniformLocation(planeProgram, 'LightPos');//
            
            planeProgram.Falloff = gl.getUniformLocation(planeProgram, 'Falloff');//未实现
            planeProgram.Resolution = gl.getUniformLocation(planeProgram, 'Resolution');
            planeProgram.AmbientColor = gl.getUniformLocation(planeProgram, 'AmbientColor');
            planeProgram.a_Position = gl.getAttribLocation(planeProgram, 'a_Position');//
            planeProgram.a_Normal = gl.getAttribLocation(planeProgram, 'a_Normal');
            planeProgram.a_TexCoord = gl.getAttribLocation(planeProgram, 'TexCoord0');//


            planeProgram.u_MvpMatrix = gl.getUniformLocation(planeProgram, 'u_MvpMatrix');//
            //planeProgram.u_ModelMatrix = gl.getUniformLocation(planeProgram, 'u_ModelMatrix');
            //planeProgram.u_NormalMatrix = gl.getUniformLocation(planeProgram, 'u_normalMatrix');
            planeProgram.diffuseMap = gl.getUniformLocation(planeProgram, 'u_texture0');//
            planeProgram.normalMap = gl.getUniformLocation(planeProgram, 'u_normals');//


            // Set the vertex information
            var cubeLight = initVertexBuffers(gl);

            var planeObject = initPlaneVertexBuffers(gl);
            if (!planeObject) {
                console.log('Failed to set the vertex information');
                return;
            }
            //var windowObject = initWindowVertexBuffers(gl);
            // Set texture
            var diffuseMap = initTextures(gl, planeProgram, '../images/brick-diffuse.png',planeProgram.diffuseMap, 0);
            var normalMap = initTextures(gl, planeProgram, '../images/brick-normals.png', planeProgram.normalMap, 1);
            if (!diffuseMap || !normalMap) {
                console.log('Failed to intialize the texture.');
                return;
            }

            // Set the clear color and enable the depth test
            gl.enable(gl.DEPTH_TEST);
            //gl.enable(gl.BLEND);
            //gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
            gl.clearColor(0.0, 0.0, 0.0, 1.0);

            // Calculate the view projection matrix
            cameraPos = [0.0, 5.0, 10.0];
            light_Pos = new Vector3([-2.0, 2.0, -2.0]);
            var viewProjMatrix = new Matrix4();
            viewProjMatrix.setPerspective(45.0, canvas.width / canvas.height, 1.0, 100.0);
            viewProjMatrix.lookAt(cameraPos[0], cameraPos[1], cameraPos[2], 0, 0, 0, 0, 1, 0);

            // Start drawing
            var currentAngle = 0.0; // Current rotation angle (degrees)
            var tick = function () {
                currentAngle = animate(currentAngle);  // Update current rotation angle
                gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT); // Clear color and depth buffers
                // Draw the light source
                drawLight(gl, lightProgram, cubeLight, 2.0, currentAngle, viewProjMatrix);
                // Draw a cube in single color
                drawPlane(gl, planeProgram, planeObject, diffuseMap, normalMap, 0.0, 20.0, viewProjMatrix);
                requestAnimationFrame(tick, canvas);
            };
            tick();
        }

        window.addEventListener("mousemove", function (ev) {
            mouse.x = ev.pageX / canvas.width;
            mouse.y = 1.0 - ev.pageY / canvas.height;
        }, true);

        function calDelta() {
            //get delta time for smooth animation
            now = Date.now();
            var delta = (now - lastTime) / 1000;
            lastTime = now;
            //animate the camera by scrolling UV offsets
            time += 0.25 * delta;

            //we can scale the coordinates to create a "zoom"        
            var zoom = 1 - ((Math.sin(time) / 2 + 0.5) * 0.15);

            //determine how many repeats we need to fit nicely within the window 
            var xrepeats = (canvas.width / MAPWITH) * zoom;
            var yrepeats = (canvas.height / MAPHEIGHT) * zoom;

            //now offset the position of the UVs with some sin magic
            var xpos = -xrepeats + Math.sin(Math.sin(time * 0.5)),
                ypos = -yrepeats + Math.sin(time * 0.25);
            return { xrepeats: xrepeats, yrepeats: yrepeats, xpos: xpos, ypos: ypos };
        }

        function initVertexBuffers(gl) {
            // Create a cube
            //    v6----- v5
            //   /|      /|
            //  v1------v0|
            //  | |      | |
            //  | |v7---|-|v4
            //  |/      |/
            //  v2------v3

            var vertices = new Float32Array([   // Vertex coordinates
               1.0, 1.0, 1.0, -1.0, 1.0, 1.0, -1.0, -1.0, 1.0, 1.0, -1.0, 1.0,    // v0-v1-v2-v3 front
               1.0, 1.0, 1.0, 1.0, -1.0, 1.0, 1.0, -1.0, -1.0, 1.0, 1.0, -1.0,    // v0-v3-v4-v5 right
               1.0, 1.0, 1.0, 1.0, 1.0, -1.0, -1.0, 1.0, -1.0, -1.0, 1.0, 1.0,    // v0-v5-v6-v1 up
              -1.0, 1.0, 1.0, -1.0, 1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, 1.0,    // v1-v6-v7-v2 left
              -1.0, -1.0, -1.0, 1.0, -1.0, -1.0, 1.0, -1.0, 1.0, -1.0, -1.0, 1.0,    // v7-v4-v3-v2 down
               1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, 1.0, -1.0, 1.0, 1.0, -1.0     // v4-v7-v6-v5 back
            ]);

            //var normals = new Float32Array([   // Normal
            //   0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0,     // v0-v1-v2-v3 front
            //   1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0,     // v0-v3-v4-v5 right
            //   0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0,     // v0-v5-v6-v1 up
            //  -1.0, 0.0, 0.0, -1.0, 0.0, 0.0, -1.0, 0.0, 0.0, -1.0, 0.0, 0.0,     // v1-v6-v7-v2 left
            //   0.0, -1.0, 0.0, 0.0, -1.0, 0.0, 0.0, -1.0, 0.0, 0.0, -1.0, 0.0,     // v7-v4-v3-v2 down
            //   0.0, 0.0, -1.0, 0.0, 0.0, -1.0, 0.0, 0.0, -1.0, 0.0, 0.0, -1.0      // v4-v7-v6-v5 back
            //]);

            //var texCoords = new Float32Array([   // Texture coordinates
            //   1.0, 1.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0,    // v0-v1-v2-v3 front
            //   0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 1.0, 1.0,    // v0-v3-v4-v5 right
            //   1.0, 0.0, 1.0, 1.0, 0.0, 1.0, 0.0, 0.0,    // v0-v5-v6-v1 up
            //   1.0, 1.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0,    // v1-v6-v7-v2 left
            //   0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0, 1.0,    // v7-v4-v3-v2 down
            //   0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0, 1.0     // v4-v7-v6-v5 back
            //]);

            var indices = new Uint8Array([        // Indices of the vertices
               0, 1, 2, 0, 2, 3,    // front
               4, 5, 6, 4, 6, 7,    // right
               8, 9, 10, 8, 10, 11,    // up
              12, 13, 14, 12, 14, 15,    // left
              16, 17, 18, 16, 18, 19,    // down
              20, 21, 22, 20, 22, 23     // back
            ]);

            var o = new Object(); // Utilize Object to to return multiple buffer objects together

            // Write vertex information to buffer object
            o.vertexBuffer = initArrayBufferForLaterUse(gl, vertices, 3, gl.FLOAT);
            //o.normalBuffer = initArrayBufferForLaterUse(gl, normals, 3, gl.FLOAT);
            //o.texCoordBuffer = initArrayBufferForLaterUse(gl, texCoords, 2, gl.FLOAT);
            o.indexBuffer = initElementArrayBufferForLaterUse(gl, indices, gl.UNSIGNED_BYTE);
            if (!o.vertexBuffer  || !o.indexBuffer) return null;

            o.numIndices = indices.length;

            // Unbind the buffer object
            gl.bindBuffer(gl.ARRAY_BUFFER, null);
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);

            return o;
        }

        function testQuad(gl) {
            var verticesCoords = new Float32Array([
             // Vertex coordinates, texture coordinate
             -1.0, 1.0, 0.0,
             -1.0, -1.0, 0.0,
              1.0, -1.0, 0.0,
              1.0, 1.0, 0.0
            ]);

            var indices = new Uint8Array([        // Indices of the vertices
                0, 1, 2, 0, 2, 3   // front
            ]);
            var n = indices.length; // The number of vertices

            var o = {};
            o.vertexBuffer = initArrayBufferForLaterUse(gl, verticesCoords, 3, gl.FLOAT);
            //o.texCoordBuffer = initArrayBufferForLaterUse(gl, texCoords, 2, gl.FLOAT);
            //o.normalBuffer = initArrayBufferForLaterUse(gl, normals, 3, gl.FLOAT);
            o.indexBuffer = initElementArrayBufferForLaterUse(gl, indices, gl.UNSIGNED_BYTE);
            o.numIndices = indices.length;

            // Unbind the buffer object
            gl.bindBuffer(gl.ARRAY_BUFFER, null);
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);

            return o;
        }

        //初始化相关数据
        function initPlaneVertexBuffers(gl) {
            var pos1 = new Vector3([-1.0, 1.0, 0.0]);
            var pos2 = new Vector3([-1.0, -1.0, 0.0]);
            var pos3 = new Vector3([1.0, -1.0, 0.0]);
            var pos4 = new Vector3([1.0, 1.0, 0.0]);
            var verticesCoords = new Float32Array([
              // Vertex coordinates, texture coordinate
              -1.0, 1.0, 0.0,
              -1.0, -1.0, 0.0,
               1.0, 1.0, 0.0,
               1.0, -1.0, 0.0
            ]);
            var texCoords = new Float32Array([
              //texture coordinate
              0.0, 1.0,
              0.0, 0.0,
              1.0, 0.0,
              1.0, 1.0
            ]);
            var nm = [0.0, 0.0, 1.0];

            var indices = new Uint8Array([        // Indices of the vertices
                0, 1, 2, 0, 2, 3   // front
            ]);
            var n = indices.length; // The number of vertices
            var quadVertices = new Float32Array([
                pos1.elements[0], pos1.elements[1], pos1.elements[2],  texCoords[0], texCoords[1], 1.0,1.0,1.0,
                pos2.elements[0], pos2.elements[1], pos2.elements[2], texCoords[2], texCoords[3], 1.0,1.0,1.0,
                pos3.elements[0], pos3.elements[1], pos3.elements[2],  texCoords[4], texCoords[5], 1.0,1.0,1.0,
                pos4.elements[0], pos4.elements[1], pos4.elements[2],  texCoords[6], texCoords[7], 1.0,1.0,1.0
            ]);

            var o = {};
            //o.vertexBuffer = initArrayBufferForLaterUse(gl, verticesCoords, 3, gl.FLOAT);
            //o.texCoordBuffer = initArrayBufferForLaterUse(gl, texCoords, 2, gl.FLOAT);
            //o.normalBuffer = initArrayBufferForLaterUse(gl, normals, 3, gl.FLOAT);
            o.quadVerticesBuffer = initArrayBufferForLaterUse(gl, quadVertices, 8, gl.FLOAT);
            o.indexBuffer = initElementArrayBufferForLaterUse(gl, indices, gl.UNSIGNED_BYTE);
            o.numIndices = indices.length;

            // Unbind the buffer object
            gl.bindBuffer(gl.ARRAY_BUFFER, null);
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);

            return o;
        }

        function initTextures(gl, program, url,location,index) {
            var texture = gl.createTexture();   // Create a texture object
            if (!texture) {
                console.log('Failed to create the texture object');
                return null;
            }

            var image = new Image();  // Create a image object
            if (!image) {
                console.log('Failed to create the image object');
                return null;
            }
            // Register the event handler to be called when image loading is completed
            image.onload = function () {
                // Write the image data to texture object
                gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, 1);  // Flip the image Y coordinate
                gl.activeTexture(gl.TEXTURE0+index);
                gl.bindTexture(gl.TEXTURE_2D, texture);
                //gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);

                // Pass the texure unit 0 to u_Sampler
                gl.useProgram(program);
                gl.uniform1i(location, index);

                gl.bindTexture(gl.TEXTURE_2D, null); // Unbind texture
            };

            // Tell the browser to load an Image
            image.src = url;

            return texture;
        }

        function drawLight(gl, program, o, x, angle, viewProjMatrix) {
            gl.useProgram(program);   // Tell that this program object is used

            // Assign the buffer objects and enable the assignment
            var vertexBuffer = o.vertexBuffer;
            var fsize = vertexBuffer.FSIZE;
            gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
            initAttributeVariable(gl, program.a_Position, 3, vertexBuffer.num * fsize, 0 * fsize); // Vertex coordinates
            gl.uniform3f(program.u_lightColor, 1.0, 1.0, 1.0);
            //initAttributeVariable(gl, program.a_Normal, o.normalBuffer);   // Normal
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, o.indexBuffer);  // Bind indices

            drawLightCube(gl, program, o, x, angle, viewProjMatrix);   // Draw
        }

        function drawPlane(gl, program, o, texture,texture_normal, x, angle, viewProjMatrix) {
            gl.useProgram(program);   // Tell that this program object is used

            gl.uniform4f(program.u_lightColor, 1.0, 1.0, 1.0, 1.0);
            gl.uniform3f(program.u_lightPos, light_Pos.elements[0], light_Pos.elements[1], light_Pos.elements[2]);
            //gl.uniform3f(program.u_viewPos, cameraPos[0], cameraPos[1], cameraPos[2]);
            gl.uniform3f(program.Falloff, 0.4, 7.0, 40.0);
            gl.uniform4f(program.AmbientColor, 0.2, 0.2, 0.2,0.5);
            gl.uniform2f(program.Resolution, canvas.width, canvas.height);
            
            // Assign the buffer objects and enable the assignment
            var quadVerticesBuffer = o.quadVerticesBuffer;
            gl.bindBuffer(gl.ARRAY_BUFFER, quadVerticesBuffer);
            var fsize = quadVerticesBuffer.FSIZE;
            initAttributeVariable(gl, program.a_Position, 3, quadVerticesBuffer.num * fsize, 0 * fsize); // Vertex coordinates
            initAttributeVariable(gl, program.a_TexCoord, 2, quadVerticesBuffer.num * fsize, 3 * fsize);   // Texture coordinates
            initAttributeVariable(gl, program.Color, 3, quadVerticesBuffer.num * fsize, 5 * fsize);   // Color
            //gl.bindBuffer(gl.ARRAY_BUFFER, o.texCoordBuffer);
            //gl.vertexAttribPointer(program.a_TexCoord, 2, gl.FLOAT, false, 0, 0);
            //gl.enableVertexAttribArray(program.a_TexCoord);
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, o.indexBuffer);  // Bind indices
            gl.activeTexture(gl.TEXTURE0);
            gl.bindTexture(gl.TEXTURE_2D, texture);
            gl.activeTexture(gl.TEXTURE1);
            gl.bindTexture(gl.TEXTURE_2D, texture_normal);
            drawQuad(gl, program, o, x, angle, viewProjMatrix);
        }


        // Assign the buffer objects and enable the assignment
        function initAttributeVariable(gl, a_attribute,num,stride, offset) {
            //gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
            gl.vertexAttribPointer(a_attribute, num, gl.FLOAT, false, stride, offset);
            gl.enableVertexAttribArray(a_attribute);
        }

        function drawQuad(gl, program, o, x, angle, viewProjMatrix) {
            var g_modelMatrix = new Matrix4();
            var g_mvpMatrix = new Matrix4();
            var g_normalMatrix = new Matrix4();
            // Calculate a model matrix
            g_modelMatrix.setTranslate(0.0, 0.0, 0.0);
            g_modelMatrix.rotate(-20.0, 1.0, 0.0, 0.0);
            //g_modelMatrix.rotate(angle, 0.0, 1.0, 0.0);
            g_modelMatrix.scale(4,4, 1);

            // Calculate model view projection matrix and pass it to u_MvpMatrix
            g_mvpMatrix.set(viewProjMatrix);
            g_mvpMatrix.multiply(g_modelMatrix);
            // Calculate transformation matrix for normals and pass it to u_NormalMatrix
            g_normalMatrix.setInverseOf(g_modelMatrix);
            g_normalMatrix.transpose();
            //gl.uniformMatrix4fv(program.u_ModelMatrix, false, g_modelMatrix.elements);
            gl.uniformMatrix4fv(program.u_MvpMatrix, false, g_mvpMatrix.elements);
            //gl.uniformMatrix4fv(program.u_NormalMatrix, false, g_normalMatrix.elements);

            gl.drawElements(gl.TRIANGLES, o.numIndices, o.indexBuffer.type, 0);   // Draw
        }


        function drawLightCube(gl, program, o, x, angle, viewProjMatrix) {
            // Coordinate transformation matrix
            var g_modelMatrix = new Matrix4();
            var g_mvpMatrix = new Matrix4();
            var g_normalMatrix = new Matrix4();
            // Calculate a model matrix
            //light_Pos.elements[0] = Math.cos(angle / 180 * Math.PI) * 3.0;
           //light_Pos.elements[2] = Math.sin(angle / 180 * Math.PI) * 3.0;
            g_modelMatrix.translate(light_Pos.elements[0], light_Pos.elements[1], light_Pos.elements[2]);
            //g_modelMatrix.setTranslate(x, 0.0, 0.0);
            g_modelMatrix.rotate(20.0, 1.0, 0.0, 0.0);
            //g_modelMatrix.rotate(angle, 0.0, 1.0, 0.0);
            g_modelMatrix.scale(0.1, 0.1, 0.1);

            // Calculate model view projection matrix and pass it to u_MvpMatrix
            g_mvpMatrix.set(viewProjMatrix);
            g_mvpMatrix.multiply(g_modelMatrix);
            gl.uniformMatrix4fv(program.u_lightmvpMatrix, false, g_mvpMatrix.elements);

            gl.drawElements(gl.TRIANGLES, o.numIndices, o.indexBuffer.type, 0);   // Draw
        }

        function initArrayBufferForLaterUse(gl, data, num, type) {
            var buffer = gl.createBuffer();   // Create a buffer object
            if (!buffer) {
                console.log('Failed to create the buffer object');
                return null;
            }
            // Write date into the buffer object
            gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
            gl.bufferData(gl.ARRAY_BUFFER, data, gl.STATIC_DRAW);

            // Keep the information necessary to assign to the attribute variable later
            buffer.num = num;
            buffer.type = type;
            buffer.FSIZE = data.BYTES_PER_ELEMENT;

            return buffer;
        }

        function initElementArrayBufferForLaterUse(gl, data, type) {
            var buffer = gl.createBuffer();　  // Create a buffer object
            if (!buffer) {
                console.log('Failed to create the buffer object');
                return null;
            }
            // Write date into the buffer object
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, buffer);
            gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, data, gl.STATIC_DRAW);

            buffer.type = type;

            return buffer;
        }

        var ANGLE_STEP = 30;   // The increments of rotation angle (degrees)

        var last = Date.now(); // Last time that this function was called
        function animate(angle) {
            var now = Date.now();   // Calculate the elapsed time
            var elapsed = now - last;
            last = now;
            // Update the current rotation angle (adjusted by the elapsed time)
            var newAngle = angle + (ANGLE_STEP * elapsed) / 1000.0;
            return newAngle % 360;
        }
    </script>
</head>
<body onload="main()">
    <canvas id="webgl" width="512" height="512">
        Please use a browser that supports "canvas"
    </canvas>
</body>
</html>